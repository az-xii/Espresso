IMPORT: import
ID: io
NEWLINE: \n
IMPORT: import
ID: math
NEWLINE: \n
TYPE: int
ID: a
EQUAL: =
NUMBER: 10
NEWLINE: \n
TYPE: float
ID: b
EQUAL: =
NUMBER: 3.5
NEWLINE: \n
TYPE: decimal
ID: price
EQUAL: =
NUMBER: 19.99
NEWLINE: \n
TYPE: str
ID: name
EQUAL: =
STRING: "Espresso"
NEWLINE: \n
TYPE: bool
ID: isActive
EQUAL: =
TRUE: true
NEWLINE: \n
TYPE: bin
ID: mask
EQUAL: =
BINARY: 0b1010_1100
NEWLINE: \n
TYPE: hex
ID: color
EQUAL: =
HEX: 0xFF00FF
NEWLINE: \n
TYPE: oct
ID: perm
EQUAL: =
OCT: 0o755
NEWLINE: \n
TYPE: str
ID: greeting
EQUAL: =
FSTRING_START: f"
STRING_CONTENT: Hello, 
INTERPOLATION_START: ${
ID: name
INTERPOLATION_END: }
STRING_CONTENT: ! Your price is $
INTERPOLATION_START: ${
ID: price
INTERPOLATION_END: }
FSTRING_END: "
NEWLINE: \n
ID: io
DOT: .
ID: output
LPAR: (
ID: greeting
RPAR: )
NEWLINE: \n
TYPE: list
LBRACK: [
TYPE: var
LBRACK: [
TYPE: int
COMMA: ,
TYPE: str
RBRACK: ]
RBRACK: ]
ID: nums
EQUAL: =
LBRACK: [
NUMBER: 1
COMMA: ,
NUMBER: 2
COMMA: ,
NUMBER: 3
COMMA: ,
NUMBER: 4
COMMA: ,
NUMBER: 5
RBRACK: ]
NEWLINE: \n
TYPE: set
LBRACK: [
TYPE: str
RBRACK: ]
ID: tags
EQUAL: =
LBRACE: {
STRING: "alpha"
COMMA: ,
STRING: "beta"
RBRACE: }
NEWLINE: \n
TYPE: map
LBRACK: [
TYPE: str
COMMA: ,
TYPE: int
RBRACK: ]
ID: scores
EQUAL: =
LBRACE: {
NEWLINE: \n
INDENT: INDENT(4)
STRING: "Alice"
COLON: :
NUMBER: 95
COMMA: ,
NEWLINE: \n
STRING: "Bob"
COLON: :
NUMBER: 87
NEWLINE: \n
DEDENT: DEDENT(4)
RBRACE: }
NEWLINE: \n
TYPE: tuple
LBRACK: [
TYPE: int
COMMA: ,
TYPE: str
RBRACK: ]
ID: pair
EQUAL: =
LPAR: (
NUMBER: 42
COMMA: ,
STRING: "answer"
RPAR: )
NEWLINE: \n
IF: if
ID: a
MORETHAN: >
NUMBER: 5
LBRACE: {
NEWLINE: \n
INDENT: INDENT(4)
ID: io
DOT: .
ID: output
LPAR: (
STRING: "a is greater than 5"
RPAR: )
NEWLINE: \n
DEDENT: DEDENT(4)
RBRACE: }
ELIF: elif
ID: a
EQUAL_EQUAL: ==
NUMBER: 5
LBRACE: {
NEWLINE: \n
INDENT: INDENT(4)
ID: io
DOT: .
ID: output
LPAR: (
STRING: "a is equal to 5"
RPAR: )
NEWLINE: \n
DEDENT: DEDENT(4)
RBRACE: }
ELSE: else
COLON: :
NEWLINE: \n
INDENT: INDENT(4)
ID: io
DOT: .
ID: output
LPAR: (
STRING: "a is less than 5"
RPAR: )
NEWLINE: \n
DEDENT: DEDENT(4)
RBRACE: }
NEWLINE: \n
WHILE: while
ID: b
LESSTHAN: <
NUMBER: 10
LBRACE: {
NEWLINE: \n
INDENT: INDENT(4)
ID: b
PLUS_ASSIGN: +=
NUMBER: 1.0
NEWLINE: \n
ID: io
DOT: .
ID: output
LPAR: (
FSTRING_START: f"
STRING_CONTENT: b is now {b}
FSTRING_END: "
RPAR: )
NEWLINE: \n
DEDENT: DEDENT(4)
RBRACE: }
NEWLINE: \n
FOR: for
TYPE: int
ID: i
IN: in
ID: nums
LBRACE: {
NEWLINE: \n
INDENT: INDENT(4)
ID: io
DOT: .
ID: output
LPAR: (
FSTRING_START: f"
STRING_CONTENT: Number: {i}
FSTRING_END: "
RPAR: )
NEWLINE: \n
DEDENT: DEDENT(4)
RBRACE: }
NEWLINE: \n
FOR: for
TYPE: int
ID: i
COMMA: ,
TYPE: str
ID: tag
IN: in
ID: enumerate
LPAR: (
ID: tags
RPAR: )
LBRACE: {
NEWLINE: \n
INDENT: INDENT(4)
ID: io
DOT: .
ID: output
LPAR: (
FSTRING_START: f"
STRING_CONTENT: Tag {i}: {tag}
FSTRING_END: "
RPAR: )
NEWLINE: \n
DEDENT: DEDENT(4)
RBRACE: }
NEWLINE: \n
FOR: for
TYPE: int
ID: i
EQUAL: =
NUMBER: 0
COMMA: ,
ID: i
LESSTHAN: <
NUMBER: 10
COMMA: ,
ID: i
PLUS_ASSIGN: +=
NUMBER: 2
LBRACE: {
NEWLINE: \n
INDENT: INDENT(4)
ID: io
DOT: .
ID: output
LPAR: (
FSTRING_START: f"
STRING_CONTENT: Even number: {i}
FSTRING_END: "
RPAR: )
NEWLINE: \n
DEDENT: DEDENT(4)
RBRACE: }
NEWLINE: \n
FUNC: func
ID: add
LPAR: (
TYPE: int
ID: x
COMMA: ,
TYPE: int
ID: y
RPAR: )
ARROW: ->
TYPE: int
LBRACE: {
NEWLINE: \n
INDENT: INDENT(4)
RETURN: return
ID: x
PLUS: +
ID: y
NEWLINE: \n
DEDENT: DEDENT(4)
RBRACE: }
NEWLINE: \n
TYPE: int
ID: result
EQUAL: =
ID: add
LPAR: (
NUMBER: 5
COMMA: ,
NUMBER: 7
RPAR: )
NEWLINE: \n
ID: io
DOT: .
ID: output
LPAR: (
FSTRING_START: f"
STRING_CONTENT: Result of addition: {result}
FSTRING_END: "
RPAR: )
NEWLINE: \n
TYPE: list
LBRACK: [
TYPE: int
RBRACK: ]
ID: numbers
EQUAL: =
LBRACK: [
NUMBER: 7
COMMA: ,
NUMBER: 3
COMMA: ,
NUMBER: 5
COMMA: ,
NUMBER: 2
COMMA: ,
NUMBER: 8
RBRACK: ]
NEWLINE: \n
FUNC: func
ID: processItems
LPAR: (
TYPE: list
LBRACK: [
TYPE: int
RBRACK: ]
ID: items
COMMA: ,
FUNC: func
LPAR: (
TYPE: int
RPAR: )
ARROW: ->
TYPE: int
ID: transform
RPAR: )
ARROW: ->
TYPE: void
LBRACE: {
NEWLINE: \n
INDENT: INDENT(4)
FOR: for
LPAR: (
TYPE: int
ID: item
IN: in
ID: items
RPAR: )
LBRACE: {
NEWLINE: \n
INDENT: INDENT(8)
ID: io
DOT: .
ID: output
LPAR: (
ID: transform
LPAR: (
ID: item
RPAR: )
RPAR: )
NEWLINE: \n
DEDENT: DEDENT(8)
RBRACE: }
NEWLINE: \n
DEDENT: DEDENT(4)
RBRACE: }
NEWLINE: \n
ID: processItems
LPAR: (
ID: numbers
COMMA: ,
FUNC: func
LPAR: (
TYPE: int
ID: x
RPAR: )
ARROW: ->
TYPE: int
LBRACE: {
RETURN: return
ID: x
STAR: *
NUMBER: 2
RBRACE: }
RPAR: )
NEWLINE: \n
ID: abstract
NEWLINE: \n
CLASS: class
ID: Vector
LBRACE: {
NEWLINE: \n
INDENT: INDENT(4)
TYPE: map
LBRACK: [
TYPE: string
COMMA: ,
TYPE: decimal
RBRACK: ]
ID: subvectors
NEWLINE: \n
PUBLIC: public
FUNC: func
ID: GetMagnitude
LPAR: (
RPAR: )
ARROW: ->
TYPE: decimal
LBRACE: {
NEWLINE: \n
INDENT: INDENT(8)
TYPE: decimal
ID: sum
EQUAL: =
NUMBER: 0
NEWLINE: \n
FOR: for
LPAR: (
TYPE: decimal
ID: value
IN: in
ID: subvectors
DOT: .
ID: values
LPAR: (
RPAR: )
RPAR: )
LBRACE: {
NEWLINE: \n
INDENT: INDENT(12)
ID: sum
PLUS_ASSIGN: +=
ID: value
STAR: *
ID: value
NEWLINE: \n
DEDENT: DEDENT(12)
RBRACE: }
NEWLINE: \n
RETURN: return
ID: math
DOT: .
ID: sqrt
LPAR: (
ID: sum
RPAR: )
NEWLINE: \n
DEDENT: DEDENT(8)
RBRACE: }
NEWLINE: \n
DEDENT: DEDENT(4)
CLASS: class
ID: Vector2D
LPAR: (
ID: Vector
RPAR: )
COLON: :
LBRACE: {
NEWLINE: \n
INDENT: INDENT(4)
FUNC: func
ID: Vector
LPAR: (
TYPE: decimal
ID: x
COMMA: ,
TYPE: decimal
ID: y
RPAR: )
LBRACE: {
NEWLINE: \n
INDENT: INDENT(8)
ID: this
ARROW: ->
ID: subvectors
LBRACK: [
STRING: "x"
RBRACK: ]
EQUAL: =
ID: x
NEWLINE: \n
ID: this
ARROW: ->
ID: subvectors
LBRACK: [
STRING: "y"
RBRACK: ]
EQUAL: =
ID: y
NEWLINE: \n
DEDENT: DEDENT(8)
RBRACE: }
NEWLINE: \n
STATIC: static
NEWLINE: \n
PUBLIC: public
FUNC: func
ID: FromPolar
LPAR: (
TYPE: decimal
ID: rad
COMMA: ,
TYPE: decimal
ID: theta
RPAR: )
LBRACE: {
NEWLINE: \n
INDENT: INDENT(8)
ID: x
EQUAL: =
ID: rad
STAR: *
ID: math
DOT: .
ID: cos
LPAR: (
ID: theta
RPAR: )
NEWLINE: \n
ID: y
EQUAL: =
ID: rad
STAR: *
ID: math
DOT: .
ID: sin
LPAR: (
ID: theta
RPAR: )
NEWLINE: \n
RETURN: return
ID: Vector
LPAR: (
ID: x
COMMA: ,
ID: y
RPAR: )
NEWLINE: \n
DEDENT: DEDENT(8)
RBRACE: }
NEWLINE: \n
DEDENT: DEDENT(4)
RBRACE: }
NEWLINE: \n
